Flutter的dart代码默认运行在root isolate，即便是创建的异步future方法也不例外，而对于耗时方法势必会导致UI线程阻塞，从而导致卡顿。如何解决这个问题呢，那就是针对耗时的操作，需要创建新的isolate，isolate采用的是同一进程内的多线程间内存不共享的设计方案。dart语言之所以这样设计isolate，是为了避免线程竞争出现。正因为isolate之间无法共享内存数据，为此同时设计了套SendPort/ReceivePort的Port端口通信机制，让各isolate间彼此独立，但又可以相互的通信。对于port通信的实现原理其实还是异步消息机制。Dart的Isolate是由Dart VM管理的，对于Flutter引擎也无法直接访问。

# Isolate 是什么？

正如前面解释过的， Isolate 是 Dart 中的 线程。然而，它与常规「线程」的实现存在较大差异，这也是将其命名为「Isolate」的原因。

> 「Isolate」在 Flutter 中并不共享内存。不同「Isolate」之间通过「消息」进行通信。

# 每个 Isolate 都有自己的事件循环

每个「Isolate」都拥有自己的「事件循环」及队列（MicroTask 和 Event）。这意味着在一个 Isolate 中运行的代码与另外一个 Isolate 不存在任何关联。多亏了这一点，我们可以获得并行处理的能力。

# 我应该什么时候使用 Futures 和 Isolate？

用户将根据不同的因素来评估应用的质量，比如：

1. 特性
2. 外观
3. 用户友好性

你的应用可以满足以上所有因素，但如果用户在一些处理过程中遇到了卡顿，这极有可能对你不利。
因此，以下是你在开发过程中应该系统考虑的一些点：

* 如果代码片段不能被中断，使用传统的同步过程（一个或多个相互调用的方法）；
* 如果代码片段可以独立运行而不影响应用的性能，可以考虑通过 Future 使用事件循环；
* 如果繁重的处理可能需要一些时间才能完成，并且可能影响应用的性能，考虑使用 Isolate。

换句话说，建议尽可能地使用 Future（直接或间接地通过 async 方法），因为一旦事件循环拥有空闲时间，这些 Future 的代码就会被执行。这将使用户感觉事情正在被并行处理（而我们现在知道事实并非如此）。
另外一个可以帮助你决定使用 Future 或 Isolate 的因素是运行某些代码所需要的平均时间。

* 如果一个方法需要几毫秒 => Future
* 如果一个处理流程需要几百毫秒 => Isolate

以下是一些很好的 Isolate 选项：

* JSON 解码：解码 JSON（HttpRequest 的响应）可能需要一些时间 => 使用 compute
* 加密：加密可能非常耗时 => Isolate
* 图像处理：处理图像（比如：剪裁）确实需要一些时间来完成 => Isolate
* 从 Web 加载图像：该场景下，为什么不将它委托给一个完全加载后返回完整图像的 Isolate？